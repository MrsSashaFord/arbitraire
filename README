Arbitraire

	An arbitrary precision mathematics library. 
	
	Arbitraire supports a pure mathematics number system of continuous and
	arbitrarily sized fractional datum.

	The algorithms used are fast, and contain no known bugs in the
	fundamental operations. This library is competitive in regards to
	speed with other arbitrary precision implementations 
	
	Special care was taken to never compromise by shifting numbers around 
	in such a way as to force correct results. In effect, I believe 
	arbitraire's number system to naturally reflect the way numbers 
	actually work. In doing so, we were able to drop lines of code and 
	expose an intrepid and interesting underlying system. In this way, what
	you see is what you get, and the numerical requests you make are the 
	ones used internally.

	Division:
		Knuth's algorithm D is used for division. Faster division
	algorithms do exist, but in general Knuth's algorithm D is one of 
	the fastest division algorithms and suffices for production grade
	arbitrary precision methods. Care was taken to follow Knuth's TAOCP
	methods as closely as possible. In this way, arbitraire's division 
	algorithm is not merely a typical long division algorithm.

	Subtraction and addition:
		These algorithms are somewhat novel and are of my own
	design, they use an offset mechanism which makes them in principle
	identical to pen+paper pure mathematics routines.

	Multiplication:
		Partial carry modified school book multiplication is used.
	This algorithm was thought to be the fastest there was up to the time
	of Karatsuba. Plans to add Karatsuba multiplication and Fast Fourier
	Transformation multiplication are in the works. I believe however,
	that you'll nonetheless find our current algorithm to be sufficient
	for most purposes. And indeed it is sufficient for implementing a
	performant square root.

	Square root:
		Newton's method is used for square root. Our square root
	algorithm is quite performant perhaps due to using a correct division
	implementation.


	Arbitraire continues research into other mathematics operations, ergo,
	other algorithms are under construction but should not be used at this 
	time. They are as follows:

		long hand square root
		karatsuba multiplication
		school book long division
		newton's method for division
		newton's method for Nth root
		fully optimized subtraction and addition


	Arbitraire strictly follows POSIX and the C99/C11 standards, ergo, it is
	portable to any POSIX compliant system and works with all of the
	architectures offered by linux. mac, netbsd, freebsd, openbsd and
	indeed many other systems. Our sponsors have supplied access to nearly
	endless amounts of hardware and operating systems with which to verify
	this.


	Arbitraire's "fxdpnt" number system allows for efficient, POSIX compliant
	implementations of POSIX bc. It is a "pen and paper" style of number system
	yet with POSIX `bc' 'scale=' and printing semantics. For these semantics
	the 'base' field has to be set to 10. However, the ability to operate 
	natively in any base is left as decision to the caller of the functions.

	


	Arbitraire is an original work authored by CM Graff.


BUILDING:
---------

	git clone https://github.com/hlibc/arbitraire
	cd arbitraire
	./configure --prefix=$(pwd)/usr 
	CFLAGS="-O3" make
	make install

	Arbitraire should be built at optimization level -O3, but nonetheless
	performs fine with no optimization.

	The contents of tests/ is not installed. This method is for installing
	arbitraire on a target system, for testing and developing arbitraire
	see TESTING: below.


TESTING:
--------

	Test the core operations (add, mul, sub, div and sqrt) with a series 
	of pseudo-random 10-10000 digit numbers.

		make test


	Run the test wrappers and binaries:
	
		./tests/pseudo-random-wrapper.sh add|mul|sub|div|sqrt ...
	
		(argument agnostic, (functions of the form f(a, a, a));
		./tests/prand-a-a-a-wrapper.sh add|mul|sub|div|sqrt ...


	Automatic testing with valgrind:

		./tests/pseudo-random-wrapper.sh function valgrind
		(argument agnostic)
		./tests/prand-a-a-a-wrapper.sh function valgrind

		for instance, test square root (sqrt) with valgrind:

			./tests/prand-a-a-a-wrapper.sh sqrt valgrind


USING THE API:
--------------

	An example for writing a program to add two numbers is provided 
	below:

	#include <arbitraire/arbitraire.h>

	int main(int argc, char *argv[])
	{
		if (argc < 4 )
			arb_error("Needs 3 args, such as: 123.456 123.456 base");

		int base = atoll(argv[3]);
		fxdpnt *a, *b, *c = NULL;
		a = arb_str2fxdpnt(argv[1]);
		b = arb_str2fxdpnt(argv[2]);
		c = arb_add(a, b, c, base);
		arb_print(c);
		arb_free(a);
		arb_free(b);
		arb_free(c);
		return 0;
	}

	Compile the example program as follows:

		cc example.c libarbitraire.a -I./include

	You can also compile your programs against arbitraire by either
	installing it or by putting them inside of tests/ and running
	./configure ; make


	Bear in mind that 1 atexit slot of the C standard library is consumed
	by arbitraire in order to free its "global" (file scope variables with 
	external linkage) constants.

	If you want to use the global constants for some reason, make sure not
	to modify or free them. They are; zero, one, p5 (.5), two and ten.

	It does not make much sense to try and pre-define arbitrarily sized
	transcendental constants such as pi or e. If you need these types of
	numbers you should generate them to the needed precision or include
	them,

	Hardware types can be converted to fxdpnt bignums using hrdware2arb.

		fxdpnt *a = hrdware2arb(16123123);

	This is not a very powerful or fast function as this is not a typical
	internal operation for arbitraire. It only supports size_t. If you
	really need to use hardware types you should probably write a new set
	of functions for this. Functions such as hrdware2arb, which allocate 
	their own memory require that the caller free the memory using 
	arb_free().
	
	Arbitraire's numbers are opaque objects, but can be accessed for
	debugging using arb_size(), arb_allocated(), arb_sign() and arb_left(). 
	Details for doing this can be found inside of tests/print.c. Because of
	this, the numbers must be accessed as pure mathematical objects. Object 
	opacity helps to provide a safe and portable interface which can 
	withstand internal security changes and other updates without affecting
	the code which uses arbitraire as a bignum library.


DEBUGGING:
----------

	A special set of internal functions has been created.
	They are:

		add, sub, divv and mul.

	These functions are not exposed by the API so as to preserve the
	namespace.

	These special debugging functions have a final field, which when
	filled with a character string, will print that string and the
	function name using __func__ and finally the result of the function.

	If you don't compile with `CFLAGS=-D_ARB_DEBUG make' then it will
	not be possible to activate the final field of these functions.
	In this way, the final field can be populated but still not print
	any information if it is never replaced with a NULL or 0 prior to
	release.

	These functions are used as follows:

		mul(a, b, &c, base, scale, "message");
		divv(a, b, &c, base, scale, "message");
		add(a, b, &c, base, "message");
		sub(a, b, &c, base, "message");

	Generally, "message" would be populated with the name of the
	variable you are using for the final "answer" which goes into
	"c". The debugging functions then print the function name,
	your message, and the final "answer" whch goes into "c".

	I use them as follows:

		mul(a, b, c, base, scale, "c = ");

	C has no way of knowing the variable names verbatim as they are
	used, so in this way one can debug their work without interfering
	in the programming process with extra lines of code to print their
	results out to screen.




	
INSPIRATIONS:
-------------

	Fabrice Bellard's libBF library 
	https://bellard.org/libbf/

	GNU's GMP library

	Donald Knuth's  TAOCP


CONTACTS:
---------

	CM Graff   cm0graff@gmail.com

